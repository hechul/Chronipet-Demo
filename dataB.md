/* ==============================================
1. 유저 (Users)
- Supabase Auth와 연결
- Soft Delete 적용
============================================== */
CREATE TABLE users (
id uuid PRIMARY KEY, -- Supabase Auth UID와 동일
email varchar(255) NOT NULL UNIQUE, - 중복 X
username varchar(50) NOT NULL UNIQUE, -- 닉네임, 중복 X
password_hash varchar(255), -- 소셜 로그인 시 NULL 가능
profile_image_url text,
is_deleted boolean DEFAULT false, -- 삭제 여부
deleted_at timestamp, -- 삭제된 시간
created_at timestamp DEFAULT now(),
updated_at timestamp DEFAULT now()
);
COMMENT ON TABLE users IS '유저(Profiles)';
 
-- 유저 검색 속도 향상 (인덱스)
CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_users_username ON users(username);
CREATE INDEX idx_users_is_deleted ON users(is_deleted);
 
 
/* ==============================================
2. 반려견 (Dogs)
- 견종 ENUM 대신 유연하게 Varchar 사용
- 몸무게 로직 (0보다 커야 함)
============================================== */
CREATE TABLE dogs (
id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
user_id uuid NOT NULL REFERENCES users(id) ON DELETE CASCADE
name varchar(50) NOT NULL,
breed varchar(50), -- ‘대형견’,‘소형견’등
birth_date date,
weight decimal CHECK (weight > 0), -- 0kg인 강아지는 없다.
profile_image_url text,
is_deleted boolean DEFAULT false,
deleted_at timestamp,
created_at timestamp DEFAULT now(),
updated_at timestamp DEFAULT now()
);
COMMENT ON TABLE dogs IS '반려견';
 
CREATE INDEX idx_dogs_user_id ON dogs(user_id);
 
 
/* ==============================================
3. 펫푸드 (Products)
- JSONB로 스펙 유연하게 저장
============================================== */
CREATE TABLE products (
id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
product_name varchar(100) NOT NULL,
manufacturer varchar(100),
category varchar(50),
단백질, 재질 등 제각각인 정보를 통째로 저장
specifications jsonb,
image_url text, -- 제품 썸네일 사진 추가
rating decimal DEFAULT 0, -- 이 제품의 평균 평점 저장하는 곳
(맨 밑의 트리거로 평균 자동 계산)
is_deleted boolean DEFAULT false,
deleted_at timestamp,
created_at timestamp DEFAULT now(),
updated_at timestamp DEFAULT now()
);
COMMENT ON TABLE products IS '펫푸드_제품';
 
CREATE INDEX idx_products_name ON products(product_name);
CREATE INDEX idx_products_category ON products(category);
 CREATE INDEX idx_products_specs ON products USING GIN (specifications);
specifications 같은 JSON 데이터는 순서가 없고 뒤죽박죽임. 이를 해결하기 위해 사용하는 것이 GIN인데 오리 -> 5번 상품 , 10번 상품 이런식으로 기억해둠 일반 인덱스로는 맛이 오리인 거 찾아 라고하면 DB가 모든 상품을 하나하나 다 뜯어봐야 해서 엄청 느려짐.밑과 같은 쿼리에서 속도가 엄청빨라진다.
SELECT * FROM products WHERE specifications @> '{"ingredient": "chicken"}';
(specifications 안에 ingredient가  chicken인 것 찾기)
 
/* ==============================================
4. 리뷰/스토리 (Reviews)
- 썸네일 최적화 컬럼 포함
============================================== */
CREATE TABLE reviews (
id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
-- 관계 연결
user_id uuid NOT NULL REFERENCES users(id),
dog_id bigint NOT NULL REFERENCES dogs(id),
title varchar(255) NOT NULL,
content text NOT NULL,
-- 글 자체에 대한 평점 (0~5점)
rating decimal CHECK (rating >= 0 AND rating <= 5),
representative_image_id integer, -- 리뷰를 등록하기전에 사진들을 먼저 올리게 되는데
사진들을 올리는 테이블은 리뷰를 참조함. 사진을 올렸을 때 이게 몇 번리뷰에 들어가야하는지 모름 그래서 리뷰를 등록하고 사진을 지정해줘야하는데 리뷰를 등록하는 테이블에 이 대표 사진이 존재하기 때문에 null로 저장되고 리뷰 등록 -> 사진들 등록 -> 사진에서 대표사진을 리뷰테이블에서 지정의 3가지 과정으로 인해 느려짐. 이 컬럼 삭제 후 image 테이블로 이동 필요.
 
-- 매번 count() 하지 않고 편하게 가져오기 위함
글 목록에 글이 20개 있으면, 20번 반복하게 된다
이를 해결 ->
view_count integer DEFAULT 0,
like_count integer DEFAULT 0,
 
is_deleted boolean DEFAULT false,
deleted_at timestamp,
created_at timestamp DEFAULT now(),
updated_at timestamp DEFAULT now()
);
COMMENT ON TABLE reviews IS '리뷰(스토리)';
 
CREATE INDEX idx_reviews_user ON reviews(user_id);
CREATE INDEX idx_reviews_rating ON reviews(rating);
 
 
/* ==============================================
5. 리뷰-제품 연결 (Reviews_Products)
- 제품별 평점 따로 관리
============================================== */
CREATE TABLE reviews_products (
id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
-- 관계 연결
원래는 review_id, product_id을 PK로 두어 중복방지를 걸려 했으나,
개발의 편의성과 확장성을 고려해 별도의 id를 두는게 좋아보임.
review_id bigint NOT NULL REFERENCES reviews(id) ON DELETE CASCADE,
product_id bigint NOT NULL REFERENCES products(id),
-- "이 제품은 어땠어?" (글 평점이랑 다름)
product_rating decimal CHECK (product_rating >= 0 AND product_rating <= 5),
is_deleted boolean DEFAULT false,
created_at timestamp DEFAULT now()
);
COMMENT ON TABLE reviews_products IS '리뷰_태그_제품';
 
-- 중복 태그 방지 (복합 인덱스)
CREATE UNIQUE INDEX idx_review_product_unique ON reviews_products(review_id, product_id);
 
 
/* ==============================================
6. 리뷰 이미지 (ReviewImages)
- 순서 보장 (display_order)
============================================== */
CREATE TABLE reviewimages (
id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
-- 관계 연결
review_id bigint NOT NULL REFERENCES reviews(id) ON DELETE CASCADE,
-- 스크래핑을 통해 가져온 정보들을 삽입하기 위한 구조
image_url text NOT NULL, - 가져온 사이트 이미지 주소
storage_path text NOT NULL, - 그 이미지를 서버에 저장해둔 위치
display_order integer DEFAULT 0, -- 0, 1, 2 순서
is_representative BOOLEAN DEFAULT FALSE -- review테이블에서 이쪽으로 이동 -> 이 사진을 대표 사진으로 할 것인지 안할 것인지
is_deleted boolean DEFAULT false,
created_at timestamp DEFAULT now()
);
COMMENT ON TABLE reviewimages IS '리뷰_사진첩';
CREATE UNIQUE INDEX idx_review_representative_image 
ON reviewimages (review_id) 
WHERE is_representative = TRUE;
( 대표 사진은 하나만 true로 유일해야한다는 제약조건
대표 사진을 바꾸고 싶을 때 true가 두개이상이 안되는 것이므로 원래 대표 사진을
false로 바꾸고 다른 대표사진으로 하고싶은 사진의 is_reviewimages를 true로 바꾸는 작업 필요
-> 이를 해결하기 위해 대표 사진 교체 함수 추가
/* ==============================================
7. 댓글 (Comments)
============================================== */
CREATE TABLE comments (
id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
review_id bigint NOT NULL REFERENCES reviews(id) ON DELETE CASCADE,
user_id uuid NOT NULL REFERENCES users(id),
content text NOT NULL,
is_deleted boolean DEFAULT false,
created_at timestamp DEFAULT now(),
updated_at timestamp DEFAULT now()
);
COMMENT ON TABLE comments IS '댓글';
 
 
/* ==============================================
8. 대댓글 (Replies)
============================================== */
CREATE TABLE replies (
id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
comment_id bigint NOT NULL REFERENCES comments(id) ON DELETE CASCADE,
user_id uuid NOT NULL REFERENCES users(id),
content text NOT NULL,
is_deleted boolean DEFAULT false,
created_at timestamp DEFAULT now()
);
COMMENT ON TABLE replies IS '대댓글';
 
 
/* ==============================================
9. 좋아요 (Users_Reviews_Likes)
============================================== */
CREATE TABLE users_reviews_likes (
id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
review_id bigint NOT NULL REFERENCES reviews(id) ON DELETE CASCADE,
user_id uuid NOT NULL REFERENCES users(id) ON DELETE CASCADE,
is_deleted boolean DEFAULT false,
created_at timestamp DEFAULT now()
);
COMMENT ON TABLE users_reviews_likes IS '좋아요';
 
-- 좋아요 중복 방지
CREATE UNIQUE INDEX idx_likes_unique ON users_reviews_likes(review_id, user_id);
 
 
 



 
 
------------트리거------------
 
 
-- 날짜 갱신 함수
CREATE OR REPLACE FUNCTION update_timestamp()
RETURNS TRIGGER AS $$
BEGIN
NEW.updated_at = NOW();
RETURN NEW;
END;
$$ LANGUAGE plpgsql;
 
-- 각 테이블에 트리거 부착
CREATE TRIGGER trigger_users_updated_at BEFORE UPDATE ON users FOR EACH ROW EXECUTE FUNCTION update_timestamp();
CREATE TRIGGER trigger_dogs_updated_at BEFORE UPDATE ON dogs FOR EACH ROW EXECUTE FUNCTION update_timestamp();
CREATE TRIGGER trigger_products_updated_at BEFORE UPDATE ON products FOR EACH ROW EXECUTE FUNCTION update_timestamp();
CREATE TRIGGER trigger_reviews_updated_at BEFORE UPDATE ON reviews FOR EACH ROW EXECUTE FUNCTION update_timestamp();
CREATE TRIGGER trigger_comments_updated_at BEFORE UPDATE ON comments FOR EACH ROW EXECUTE FUNCTION update_timestamp();
 
 
 
 
-- 삭제 시간 기록 함수
CREATE OR REPLACE FUNCTION record_deleted_at()
RETURNS TRIGGER AS $$
BEGIN
-- is_deleted가 false -> true로 바뀔 때만 작동
IF (OLD.is_deleted = FALSE AND NEW.is_deleted = TRUE) THEN
NEW.deleted_at = NOW();
END IF;
-- 실수로 is_deleted를 false로 되돌리면(복구), deleted_at도 지워줌
IF (OLD.is_deleted = TRUE AND NEW.is_deleted = FALSE) THEN
NEW.deleted_at = NULL;
END IF;
 
RETURN NEW;
END;
$$ LANGUAGE plpgsql;
 
-- 테이블에 적용
CREATE TRIGGER trigger_users_soft_delete BEFORE UPDATE ON users FOR EACH ROW EXECUTE FUNCTION record_deleted_at();
CREATE TRIGGER trigger_reviews_soft_delete BEFORE UPDATE ON reviews FOR EACH ROW EXECUTE FUNCTION record_deleted_at();
CREATE TRIGGER trigger_comments_soft_delete BEFORE UPDATE ON comments FOR EACH ROW EXECUTE FUNCTION record_deleted_at();
-- 필요한 테이블에 계속 추가 가능
 
 
 
 
-- Supabase Auth 가입 시 public.users 자동 생성 트리거
create function public.handle_new_user()
returns trigger as $$
begin
insert into public.users (id, email, username)
values (new.id, new.email, new.raw_user_meta_data->>'username');
return new;
end;
$$ language plpgsql security definer;
 
create trigger on_auth_user_created
after insert on auth.users
for each row execute procedure public.handle_new_user();



-- 상품 평점 자동 계산 트리거
CREATE OR REPLACE FUNCTION update_product_rating()
RETURNS TRIGGER AS $$
DECLARE
target_product_id BIGINT;
BEGIN
IF (TG_OP = 'DELETE') THEN
target_product_id := OLD.product_id;
ELSE
target_product_id := NEW.product_id;
END IF;
 
UPDATE products
SET rating = (
SELECT COALESCE(AVG(product_rating), 0)
FROM reviews_products
WHERE product_id = target_product_id AND is_deleted = FALSE
)
WHERE id = target_product_id;
RETURN NULL;
END;
$$ LANGUAGE plpgsql;
 
 
CREATE TRIGGER trigger_update_product_rating
AFTER INSERT OR UPDATE OR DELETE ON reviews_products
FOR EACH ROW
EXECUTE FUNCTION update_product_rating();
 
-- 리뷰 좋아요 수 자동 동기화 트리거
CREATE OR REPLACE FUNCTION sync_review_like_count()
RETURNS TRIGGER AS $$
DECLARE
target_review_id BIGINT;
BEGIN
IF (TG_OP = 'INSERT' OR TG_OP = 'UPDATE') THEN
target_review_id := NEW.review_id;
ELSE
target_review_id := OLD.review_id;
END IF;
 
UPDATE reviews
SET like_count = (
SELECT COUNT(*)
FROM users_reviews_likes
WHERE review_id = target_review_id AND is_deleted = FALSE
)
WHERE id = target_review_id;
RETURN NULL;
END;
$$ LANGUAGE plpgsql;
 
CREATE TRIGGER trigger_sync_review_like_count
AFTER INSERT OR UPDATE OR DELETE ON users_reviews_likes
FOR EACH ROW
EXECUTE FUNCTION sync_review_like_count();


-- 대표 사진 교체 함수 (Transaction 보장)
-- 사용법: supabase.rpc('change_representative_image', { _review_id: 10, _image_id: 55 })
CREATE OR REPLACE FUNCTION change_representative_image(_review_id BIGINT, _image_id BIGINT)
RETURNS VOID AS $$
BEGIN
  -- 1. 해당 리뷰의 모든 사진을 일단 대표가 아니라고(False) 초기화
  UPDATE reviewimages
  SET is_representative = FALSE
  WHERE review_id = _review_id;

  -- 2. 사용자가 선택한 사진만 대표(True)로 설정
  UPDATE reviewimages
  SET is_representative = TRUE
  WHERE id = _image_id AND review_id = _review_id;
END;
$$ LANGUAGE plpgsql;

 
—----------정책—------------

-- 유저 테이블: 내 정보는 나만 수정
ALTER TABLE users ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Public profiles are viewable by everyone" ON users FOR SELECT USING (true);
CREATE POLICY "Users can update own profile" ON users FOR UPDATE USING (auth.uid() = id);
 
 
-- 리뷰 테이블: 글은 누구나 봄, 수정/삭제는 작성자만
ALTER TABLE reviews ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Reviews are public" ON reviews FOR SELECT USING (true);
CREATE POLICY "Users can create reviews" ON reviews FOR INSERT WITH CHECK (auth.uid() = user_id);
CREATE POLICY "Users can update own reviews" ON reviews FOR UPDATE USING (auth.uid() = user_id);
CREATE POLICY "Users can delete own reviews" ON reviews FOR DELETE USING (auth.uid() = user_id);
 
– 반려견 (Dogs)
ALTER TABLE dogs ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Dogs are viewable by everyone" ON dogs FOR SELECT USING (true);
CREATE POLICY "Users can insert own dogs" ON dogs FOR INSERT WITH CHECK (auth.uid() = user_id);
CREATE POLICY "Users can update own dogs" ON dogs FOR UPDATE USING (auth.uid() = user_id);
CREATE POLICY "Users can delete own dogs" ON dogs FOR DELETE USING (auth.uid() = user_id);

-- 리뷰 이미지 (ReviewImages)
ALTER TABLE reviewimages ENABLE ROW LEVEL SECURITY;
-- 누구나 볼 수 있음
CREATE POLICY "Images are viewable by everyone" ON reviewimages FOR SELECT USING (true);
-- 리뷰 작성자(주인)만 사진 추가/삭제 가능 (조인해서 확인)
CREATE POLICY "Users can insert images" ON reviewimages FOR INSERT 
WITH CHECK (auth.uid() IN (SELECT user_id FROM reviews WHERE id = review_id));
CREATE POLICY "Users can delete images" ON reviewimages FOR DELETE 
USING (auth.uid() IN (SELECT user_id FROM reviews WHERE id = review_id));

-- 댓글 (Comments)
ALTER TABLE comments ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Comments are viewable by everyone" ON comments FOR SELECT USING (true);
CREATE POLICY "Users can insert comments" ON comments FOR INSERT WITH CHECK (auth.uid() = user_id);
CREATE POLICY "Users can update own comments" ON comments FOR UPDATE USING (auth.uid() = user_id);
CREATE POLICY "Users can delete own comments" ON comments FOR DELETE USING (auth.uid() = user_id);

--  좋아요 (Users_Reviews_Likes)
ALTER TABLE users_reviews_likes ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Likes are viewable by everyone" ON users_reviews_likes FOR SELECT USING (true);
CREATE POLICY "Users can toggle likes" ON users_reviews_likes FOR ALL USING (auth.uid() = user_id);

 
평점 자동 계산과 좋아요 수 는 슈퍼베이스 환경에서 트리거로 구현하는 것이
코드로 구현하는 것보다 훨씬 쉽고 버그가 없다.
다만 이 서비스가 대규모가 된다면 트리거로는 문제가 생길 수 있다.
예를들어 초당 좋아요가 1000개씩 눌리는데 그때마다 트리거가 깨어나서 UPDATE reviews SET like_count를 실행하면 DB가 락에 걸려서 전체가 느려지거나 멈출 가능성이 있다.
이러한 대형 서비스는 서버에 일단 숫자를 쌓아두고, 나중에 한꺼번에 DB에 반영하는 방식을 사용하도록한다.

